{
  "name": "QGIS Setting Manager",
  "tagline": "QGIS setting manager is a python module to easily manage read/write settings and set/get corresponding widgets in a plugin.",
  "body": "## About\r\n\r\nEasily manage the settings in your [QGIS](http://www.qgis.org) plugin.\r\n\r\nThis module can:\r\n* manage **different types of settings** (bool, string, color, integer, double, stringlist)\r\n* **read and write settings** in QGIS application or in the QGIS project\r\n* automatically **set widgets from corresponding setting**\r\n* automatically **write settings from widgets of a dialog**\r\n\r\n\r\n## The main setting class\r\n\r\nAll your settings shall be saved in a single class, which will subclass SettingManager.\r\n\r\n```python\r\nfrom qgissettingmanager import *\r\n\r\nclass MySettings(SettingManager):\r\n    def __init__(self):\r\n        SettingManager.__init__(self, my_plugin_name)\r\n        self.add_setting( Bool(\"my_setting\", Scope.Global, True) )\r\n```\r\n    \r\nYou may add as many settings as you want using `add_setting` method:\r\n\r\n```python\r\nadd_setting( SettingClass( name, scope, default_value, options={} ) )\r\n```\r\n\r\n* `SettingClass`: `Bool`, `String`, `Color`, `Integer`, `Double` or `Stringlist`\r\n* `name`: the name of the setting\r\n* `scope`: `Scope.Global` or `Scope.Project`\r\n* `default_value`: the default value of the setting (type must correspond)\r\n* `options`: a dictionary of options for widgets (see [possible widgets](#possiblewidgets))\r\n\r\n### Access the settings\r\n\r\nInstantiate your settings class in your current class:\r\n\r\n```python\r\nimport MySettings\r\nself.settings = MySettings()\r\n```\r\n\r\nThe settings are easily accessed using the `value` and `setValue` methods:\r\n\r\n```python\r\nmyVariable = self.settings.value(\"myVariable\")\r\nself.settings.set_value(\"myVariable\", False)\r\n```\r\n\r\n### Remove settings\r\n\r\nSettings can be removed from registry (local or project wise) using `MySettings().remove('my_setting')`.\r\n\r\n\r\n## Match settings with widgets of a dialog\r\n\r\n### Quick start\r\n\r\nYou can associate a setting to a defined widget in a dialog (or a dockable window). The first condition is to **name the widget as the setting name**.\r\nThen, your dialog class shall subclass the `SettingDialog` class:\r\n\r\n```python\r\nclass MyDialog(QDialog, Ui_myDialog, SettingDialog):\r\n    def __init__(self):\r\n        QDialog.__init__(self)\r\n        self.setupUi(self)\r\n        self.settings = MySettings()\r\n        SettingDialog.__init__(self, self.settings)\r\n```\r\n\r\nHence, when the dialog is shown, all widgets which are named according to a  setting will be set to the corresponding value. On dialog acceptance, the settings will be set according to the value read from their widget.\r\n\r\nTo control which setting has been associated to a widget, you can print `self.widget_list()`.\r\n\r\n### Settings' update behavior\r\n\r\nYou can have a different behavior using `SettingDialog` parameters:\r\n\r\n```python\r\nSettingDialog(settingManager, mode=UpdateMode.DialogAccept)\r\n```\r\n\r\n`mode` can take the following values:\r\n\r\n* `UpdateMode.DialogAccept`: settings values are set when the dialog is accepted _(default)_;\r\n* `UpdateMode.WidgetUpdate`: settings are set as soon as the widget is modified.\r\n\r\n### Check something before updating the settings\r\n\r\nYou can override the `SettingDialog.before_accept_dialog()` method to check your settings.\r\nSettings will be saved only if the method returns `True`.\r\n\r\n### Using showEvent\r\n\r\nBe warned that `SettingDialog` implements `showEvent` method. Therefore, if you redefine it in your dialog class, you have to write:\r\n\r\n```python\r\ndef showEvent(self, e):\r\n    settingDialog.showEvent(self, e)\r\n    # do your own stuff\r\n```\r\n\r\n<a name=\"possiblewidgets\"/>\r\n### Possible widgets\r\n\r\nThe widgets are automatically detected by the manager. If the type of widget is not handled, an error is raised.\r\n\r\n**Strings**\r\n\r\n* QLineEdit\r\n* QComboBox (setting can be defined as the current item text or [data](http://qt-project.org/doc/qt-4.8/qcombobox.html#itemData): specify option `comboMode` as `data` (default) or `text`)\r\n* QButtonGroup (the setting is set as the checked widget text in the button group)\r\n\r\n**Booleans**\r\n\r\n* QCheckBox\r\n* Any checkable widget (groupbox, etc.)\r\n\r\n**Colors**\r\n\r\n* Native QGIS widgets (QgsColorButton, QgsColorButtonV2) or any widget (label or pushbutton are recommended). For standard Qt Widgets, QGIS [color button](http://qgis.org/api/classQgsColorButtonV2.html)) will be used. Use options `allowAlpha` (boolean) to allow transparent colors and `dialogTitle` to set the dialog title.\r\n\r\n**Integers**\r\n\r\n* QLineEdit\r\n* QSpinBox\r\n* QSlider\r\n* QComboBox (setting is set as the combo box index)\r\n\r\n**Doubles**\r\n\r\n* QLineEdit\r\n* QDoubleSpinBox\r\n\r\n**Stringlist**\r\n\r\n* QListWidget (checks items having their _text_ in the list)\r\n* QButtonGroup (checks items having their _name_ in the list)\r\n\r\nNew types of widget are easily added, if one is missing, do not hesitate to [ask](https://github.com/3nids/qgissettingmanager/issues)!\r\n\r\n\r\n## Using git submodules\r\n\r\nTo use this module, you can easily copy the files and put them in your project.\r\nA more elegant way is to use [git submodule](http://git-scm.com/book/en/Git-Tools-Submodules). Hence, you can keep up with latest improvements. In you plugin directory, do\r\n\r\n```\r\ngit submodule add https://github.com/3nids/qgissettingmanager.git\r\n```\r\n\r\nA folder _qgissettingmanager_ will be added to your plugin directory. However, git only references the module, and you can `git pull` in this folder to get the last changes.\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}